<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="initial-scale=1.0, user-scalable=no">
<title>Polynomial Calculator</title>
<style type="text/css">
html {padding: 10px 10px 200px; font-family: droid sans, sans-serif; }
body {margin: 0 auto; max-width: 580px; }
body > article > *:first-child {margin-top: 0; }
article p {line-height: 1.4em; font-size: 17px; }

textarea {width: 500px; height: 60px; padding: 10px; }
</style>

<body>
<article id="calculator">
<h1>Polynomial Calculator</h1>
<p>Readable
<p><textarea id="eq">2x + 3x - 3*4 / 6</textarea>
<p>Strict
<p><textarea id="strict"></textarea>
<p><button onclick="simplify()">Calc</button>
<!--<p><button onclick="test()">Explode</button>-->
<p>Answer
<p><pre id="answer"></pre>

</article>

<script>
function isNumber(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
}

function arraysEqual(a, b) {
    'use strict';
    var ii, len;

    if (a === b) {
        return true;
    }
    if (a === null || b === null) {
        return false;
    }
    if (a.length !== b.length) {
        return false;
    }

    a.sort();
    b.sort();

    len = a.length;
    for (ii = 0; ii < len; ii = ii + 1) {
        if (a[ii] !== b[ii]) {
            return false;
        }
    }
    return true;
}

function sameIds(words, aEq) {
    var ii, len;
    len = aEq.length;
    for (ii = 0; ii < len; ii = ii + 1) {
        if (arraysEqual(aEq[ii].idTop, words.idTop) && arraysEqual(aEq[ii].idBot, words.idBot)) {
            return ii;
        }
    }
    return -1;
}

function readableToStrict(eq) {
    // Pad spaces around * and / if needed
    eq = eq.replace(/([\*\/\^])/g, ' $1 ');
    
    // Expand adjacent coefficient/identifier to explicit multiplication
    eq = eq.replace(/(\d)([a-zA-Z])/g, '$1 * $2');
    
    // make all terms + and transport negativity to a coefficient
    //console.log(eq.match(/^(?![a-zA-Z0-9])+\-(?=[a-zA-Z0-9])/g));
    //eq = eq.replace(/^(?![a-zA-Z0-9])+\-(?=[a-zA-Z0-9])/g, ' + -');
    //eq = eq.replace(/[a-zA-Z0-9\.](\-)[a-zA-Z0-9\.]/g, ' + -');
    eq = eq.replace(/( \- )(?=\d)/g, ' + -');
    eq = eq.replace(/( \- \-)/g, ' + ');
    
    // Collapse extra spaces
    eq = eq.replace(/\s+/g, " ");
    
    return eq;
}

function test() {
    var eq, answer;
    eq = document.getElementById('eq');
    answer = document.getElementById('answer');
    answer.innerHTML = '';
    answer.innerHTML = readableToStrict(eq.value);
}

function formatIds(top, bot) {
    var output = '', ii, len;
    
    // if there are multiple ids, user ^ notation
    len = top.length;
    for (ii = 0; ii < len; ii = ii + 1) {
        
    }
    
    if (top.length) {
        output = output + top.join(' * ');
    }
    if (bot.length) {
        if (top.length) {
            output = output + ' / ';
        }
        output = output + bot.join(' / ');
    }
    return output;
}

function formatPoly(eq) {
    var ii, len, output = '';
    len = eq.length;
    for (ii = 0; ii < len; ii = ii + 1) {
        if (eq[ii].coefficient) {
            // glue terms together with + and -
            if (ii > 0) {
                if (eq[ii].coefficient > 0) {
                    output = output + ' + ';
                } else {
                    // make this - and adjust coefficient
                    output = output + ' - ';
                    eq[ii].coefficient = eq[ii].coefficient * -1;
                }
            }
            
            // Format and append ids
            if (eq[ii].coefficient === 1 && eq[ii].idTop) {
                output = output + formatIds(eq[ii].idTop, eq[ii].idBot);
            }
            if (!eq[ii].idTop && !eq.idBot) {
                output = output + eq[ii].coefficient;
            }
            if (eq[ii].coefficient !== 1 && (eq[ii].idTop || eq[ii].idBot)) {
                output = output + eq[ii].coefficient + formatIds(eq[ii].idTop, eq[ii].idBot);
            }
        }
    }
    return output;
}

function cancelIds(term) {
    var ii, len, newTop = [], iBot;
    if (term.idTop.length === 0 || term.idBot.length === 0) {
        return [term.idTop, term.idBot];
    }
    len = term.idTop.length;
    for (ii = 0; ii < len; ii = ii + 1) {
        iBot = term.idBot.indexOf(term.idTop[ii]);
        if (iBot === -1) {
            newTop.push(term.idTop[ii]);
        } else {
            term.idBot.splice(iBot, 1);
        }
    }
    return [newTop, term.idBot];
}

function combineTerms(aEq) {
    var ii, len, aNewEq = [];//, newUnits;
    len = aEq.length;
    
    if (aEq.length === 0) {
        return [];
    }

    for (ii = 1; ii < len; ii = ii + 1) {
        // if it has the same words as previous - ALL previous
        iSame = sameIds(aEq[ii], aNewEq);
        if (iSame > -1 && ii !== 0) {
            aNewEq[iSame].coefficient = aNewEq[iSame].coefficient + aEq[ii].coefficient;
        } else {
            aNewEq.push({
                'coefficient': aEq[ii].coefficient,
                'idTop': aEq[ii].idTop.sort(),
                'idBot': aEq[ii].idBot.sort()
            });
        }
    }

    return aNewEq;
}

function consolidateTerms(aEq) {
    var ii, len, jj, jLen, aNewEq = [], newUnits;
    len = aEq.length;

    for (ii = 0; ii < len; ii = ii + 1) {
        aNewEq.push({'coefficient': 1, 'idTop': [], 'idBot': []});

        // Combine values
        jLen = aEq[ii].ceTop.length;
        for (jj = 0; jj < jLen; jj = jj + 1) {
            aNewEq[ii].coefficient = aNewEq[ii].coefficient * aEq[ii].ceTop[jj];
        }

        jLen = aEq[ii].ceBot.length;
        for (jj = 0; jj < jLen; jj = jj + 1) {
            aNewEq[ii].coefficient = aNewEq[ii].coefficient / aEq[ii].ceBot[jj];
        }
        
        // cancel ids that occur in top and bot arrays
        newUnits = cancelIds(aEq[ii]);
        aNewEq[ii].idTop = newUnits[0];
        aNewEq[ii].idBot = newUnits[1];
    }

    return aNewEq;
}

function strictToPoly(eq) {
    var aTerms, ii, len, aEq = [], aFactors, jj, jLen, fact;
    // separate into terms
    aTerms = eq.split(' + ');
    len = aTerms.length;
    for (ii = 0; ii < len; ii = ii + 1) {
        aEq.push({'ceTop': [], 'ceBot': [], 'idTop': [], 'idBot': []});
        // process factors
        aFactors =  aTerms[ii].match(/(\/\s\S+)|(\* \S+)|(^\S+)/g);
        jLen = aFactors.length;
        for (jj = 0; jj < jLen; jj = jj + 1) {
            fact = aFactors[jj];
            if (fact.slice(0, 1) === '/') {
                fact = fact.slice(2);
                if (isNumber(fact)) {
                    aEq[ii].ceBot.push(fact);
                } else {
                    aEq[ii].idBot.push(fact);
                }
            } else {
                if (fact.slice(0, 1) === '*') {
                    fact = aFactors[jj].slice(2);
                }
                if (isNumber(fact)) {
                    aEq[ii].ceTop.push(fact);
                } else {
                    aEq[ii].idTop.push(fact);
                }
            }
        }
    }

    return aEq;
}

function simplify() {
    var eq,
        reEq = /[^0-9a-zA-Z\s\+\-\/\*]/g;

    eq = document.getElementById('eq').value;

    // reject bad data
    if (eq.search(reEq) > -1) {
        answer.innerHTML = 'letters, numbers, +, -, *, / only';
        return;
    }

    // coerce to strict
    eq = readableToStrict(eq);
    document.getElementById('strict').value = eq;
    
    // calculate
    // format readable
    aEq = combineTerms(consolidateTerms(strictToPoly(eq)));
    answer.innerHTML = formatPoly(aEq);
}

/*
Wow, this is fun and complex. Here are a few things I've learned so far.

There should be 3 types of polynomial representation:

    1. Human read and writeable
    2. Rigid grammar (Single spaced between all numbers, operators and identifiers, no unary signs (+, -))
    3. Object representation

("Identifiers"? We need to call words something that can be both variables, constants, and units.)

There can be steps to convert from human-formatted to rigid
There is a parser to change rigid to object
There could be a process to convert object directly to human readable

You should be able to add, subtract, multiply and divide polynomial
Multiply will be most common, You could have one like so (rigid syntax):

Circumference: poly('r * cm * 3.1415')
CmToIn: poly('in / 2.54cm')
CircAndConvertCmToIn: Circumference * CmToIn
    > r * in * 1.24 `valid polynomial`

Calculate a polynomial by replacing variables with numbers
CircAndConvertCmToIn.calc({r: 1.0})
    > 1.24in `polynomial (because it includes an identifier) get the value with poly.calc({r: 1.0}).num`

Wait, that's weird. Should the input be specified as cm? I mean, it doesn't have to be, it's just recommended.

You could do the same like so:

CircAndConvertCmToIn * poly('1.0 / r')

Calculus
--------

SalesTrajectory: p(2x + 3)
SalesTrajectory.d()
    > 2 `This is a polynomial`
SalesTrajectory.d({x: 100})
    > 2 `This is a number - It is 2 for all x, so, you know`

SalesTrajectory.i()
    > x^2 + 3x + C `polynomial`
SalesTrajectory.i({x: [100, 110]})
    > 2130 `number`

*/
window.onload = simplify;
</script>
