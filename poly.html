<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="initial-scale=1.0, user-scalable=no">
<title>Polynomial Calculator</title>
<style type="text/css">
html {padding: 10px 10px 200px; font-family: droid sans, sans-serif; }
body {margin: 0 auto; max-width: 580px; }
body > article > *:first-child {margin-top: 0; }
article p {line-height: 1.4em; font-size: 17px; }
</style>

<body>
<article id="calculator">
<h1>Polynomial Calculator</h1>

<p><textarea id="eq">2 * x + 3 * x - 3 * 4 / 6</textarea>
<p><button onclick="calc()">Combine</button>
<p><button onclick="test()">Explode</button>
<p><pre id="answer"></pre>

</article>

<script>
function isNumber(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
}

function sameWords(words, newEq) {
    console.log('sameWords');
    console.log(words, newEq);
    var ii, len;
    len = newEq.length;
    for (ii = 0; ii < len; ii = ii + 1) {
        if (newEq[ii].word === words) {
            return ii;
        }
    }
    return -1;
}

function explodeCoefficient(eq) {
    //This doesn't work (yet)
    return eq.replace(/(\d.?)(\w.?)/g, function () {
        var args = arguments;
        console.log(args);
        return args[1] + ' * ' + args[2];
    });
}

function test() {
    document.getElementById('answer').innerHTML = '';
    document.getElementById('answer').innerHTML = explodeCoefficient(document.getElementById('eq').value);
}

function formatPolynomial(eq) {
    var ii, len, output = '';
    len = eq.length;
    for (ii = 0; ii < len; ii = ii + 1) {
        if (eq[ii].num) {
            if (ii > 0) {
                output = output + ' ' + eq[ii].sign + ' ';
            }
            if (eq[ii].num === 1 && eq[ii].word) {
                output = output + eq[ii].word;
            }
            if (!eq[ii].word) {
                output = output + eq[ii].num;
            }
            if (eq[ii].num !== 1 && eq[ii].word) {
                output = output + eq[ii].num + eq[ii].word;
            }
        }
    }
    return output;
}

function addNum(poly1, poly2) {
    var num1, num2, num, sign = '+';
    num1 = poly1.num;
    num2 = poly2.num;

    if (poly1.sign === '-') {
        num1 = num1 * -1;
    }
    if (poly2.sign === '-') {
        num2 = num2 * -1;
    }

    num = num1 + num2;
    if (num < 0) {
        sign = '-';
    }
    //console.log('num', num, sign);
    return {'num': Math.abs(num), 'sign': sign};
}

function calc() {
    var eq = document.getElementById('eq').value,
        answer = document.getElementById('answer'),
        reEq = /[^0-9a-zA-Z\s\+\-\/\*]/g,
        aEq = [],
        aNewEq = [],
        ii,
        parseStart = 0,
        factorSign = '+',
        len,
        aFac,
        facNum,
        facWord,
        jj,
        jLen,
        aFacNumTop = [],
        facNumTop = 1,
        aFacNumBot = [],
        facNumBot = 1,
        aFacWordTop = [],
        facWordTop = 1,
        aFacWordBot = [],
        facWordBot = 1,
        fact = '',
        facNum,
        facWord,
        solved = [],
        factorNum = 0,
        factorWord = '',
        iSame,
        aAddNum;

    // format for splitting
    
    // to start, numbers, +, -, *, / only (no parens for now)
    // Hopefully parens will just be multiple iterations of this process

    // reject bad data
    if (eq.search(reEq) > -1) {
        answer.innerHTML = 'letters, numbers, +, -, *, / only';
        //console.log(reEq.exec(eq));
        return;
    }

    // separate into factors
    //aEq = eq.split(/ [^\+\-] /);
    len = eq.length;
    for (ii = 0; ii < len; ii = ii + 1) {
        //console.log(eq.slice(ii, ii + 3));
        if (eq.slice(ii, ii + 3) === ' + ') {
            aEq.push({'factor': eq.slice(parseStart, ii), 'sign': factorSign, 'num': 0, 'word': ''});
            factorSign = '+';
            ii = ii + 3;
            parseStart = ii;
        }
        if (eq.slice(ii, ii + 3) === ' - ') {
            aEq.push({'factor': eq.slice(parseStart, ii), 'sign': factorSign, 'num': 0, 'word': ''});
            factorSign = '-';
            ii = ii + 3;
            parseStart = ii;
        }
        if (ii === len - 1) {
            aEq.push({'factor': eq.slice(parseStart), 'sign': factorSign, 'num': 0, 'word': ''});
        }
    }

    console.log(aEq);
    
    // do math on each factor
    len = aEq.length;
    //console.log(aEq.length);
    for (ii = 0; ii < len; ii = ii + 1) {
        //console.log(ii);
        // In the future we should handle numbers left-adjacent to a word as multiply
        // We could convert it to standard right here
        
        //aEq[ii].factor = aEq[ii].factor.replace(//);
        /*aFac = aEq[ii].split(' ');
        jLen = aFace.length;
        for (jj = 0; jj < jLen; jj = jj + 1) {
            if (isNumber(aFac[jj])) {
                aFacNumTop
            } else {
                
            }
        }*/
        aFacNumTop.length = 0;
        aFacNumBot.length = 0;
        aFacWordTop.length = 0;
        aFacWordBot.length = 0;
        
        parseStart = 0;
        factorSign = '*';
        jLen = aEq[ii].factor.length;
        for (jj = 0; jj < jLen; jj = jj + 1) {
            fact = aEq[ii].factor;
            //console.log(aEq[ii].slice(jj, jj + 3));
            //console.log(jj);
            if (fact.slice(jj, jj + 3) === ' * ') {
                if (isNumber(fact.slice(parseStart, jj))) {
                    if (factorSign === '*') {
                        aFacNumTop.push(fact.slice(parseStart, jj));
                    } else {
                        aFacNumBot.push(fact.slice(parseStart, jj));
                    }
                } else {
                    if (factorSign === '*') {
                        aFacWordTop.push(fact.slice(parseStart, jj));
                    } else {
                        aFacWordBot.push(fact.slice(parseStart, jj));
                    }
                }
                factorSign = '*';
                jj = jj + 3;
                parseStart = jj;
            }
            if (fact.slice(jj, jj + 3) === ' / ') {
                if (isNumber(fact.slice(parseStart, jj))) {
                    if (factorSign === '*') {
                        aFacNumTop.push(fact.slice(parseStart, jj));
                    } else {
                        aFacNumBot.push(fact.slice(parseStart, jj));
                    }
                } else {
                    if (factorSign === '*') {
                        aFacWordTop.push(fact.slice(parseStart, jj));
                    } else {
                        aFacWordBot.push(fact.slice(parseStart, jj));
                    }
                }
                factorSign = '/';
                jj = jj + 3;
                parseStart = jj;
            }
            if (jj === jLen - 1) {
                if (isNumber(fact.slice(parseStart))) {
                    if (factorSign === '*') {
                        aFacNumTop.push(fact.slice(parseStart));
                    } else {
                        aFacNumBot.push(fact.slice(parseStart));
                    }
                } else {
                    if (factorSign === '*') {
                        aFacWordTop.push(fact.slice(parseStart));
                    } else {
                        aFacWordBot.push(fact.slice(parseStart));
                    }
                }
            }
        }
        console.log(aFacNumTop, aFacNumBot, aFacWordTop, aFacWordBot);

        // combine each factor
        // top, combine all numbers
        //console.log(ii);
        
        jLen = aFacNumTop.length;
        facNumTop = 1;
        for (jj = 0; jj < jLen; jj = jj + 1) {
            facNumTop = facNumTop * aFacNumTop[jj];
        }
        
        jLen = aFacNumBot.length;
        facNumBot = 1;
        for (jj = 0; jj < jLen; jj = jj + 1) {
            facNumBot = facNumBot * aFacNumBot[jj];
        }
        facNum = facNumTop / facNumBot;
        console.log('facnum', facNumTop, facNumBot, facNum);
        
        //facWordTop = [facNum].concat(aFacWordTop).join(' * ');
        //facWordBot = aFacWordBot.join(' / ');
        /*
        jLen = aFacWordBot.length;
        facNumBot = 1;
        for (jj = 0; jj < jLen; jj = jj + 1) {
            facNumBot = facNumBot * aFacNumBot[jj];
        }
        facNum = facNumTop / facNumBot;*/
        
        //console.log(facWordTop + facWordBot);
        aEq[ii].num = facNum;
        aEq[ii].word = aFacWordTop.join(' * ') + aFacWordBot.join(' / ');
    }
    console.log('aEq final');
    console.log(aEq);

    // combine factors into final equation
    len = aEq.length;
    if (aEq.length > 0) {
        //solved = aEq[0];
        // combine all factors with identical words (order should not matter)
        //if (ii === 0) {
            if (aEq[0].sign === '-') {
                aNewEq.push({'num': aEq[0].num * -1, 'sign': '+', 'word': aEq[0].word});
            } else {
                aNewEq.push({'num': aEq[0].num, 'sign': '+', 'word': aEq[0].word});
            }
        //}
        console.log('aNewEq first');
        console.log(aNewEq)
        
        if (aEq.length > 1) {
            for (ii = 1; ii < len; ii = ii + 1) {
                // if it has the same words as previous - ALL previous
                iSame = sameWords(aEq[ii].word, aNewEq);
                console.log('iSame', iSame);
                if (iSame > -1) {
                    aAddNum = addNum(aNewEq[iSame], aEq[ii]);
                    aNewEq[iSame].num = aAddNum.num;
                    aNewEq[iSame].sign = aAddNum.sign;
                } else {
                    aNewEq.push(aEq[ii]);
                }
            }
        }
        console.log(aNewEq);
    }
    answer.innerHTML = formatPolynomial(aNewEq);

    //eq = eq.replace(/\(/g, ' ( ');
    //eq = eq.replace(/\)/g, ' ) ');
    
    //aEq = /[0-1a-zA-Z]\+\-\*\/\s]/.test(eq);
    //aEq = /[^0-9a-zA-Z\s\+]/g.test(eq);

    //console.log(aEq);
    //eval(eq);
}

/*
Wow, this is fun and complex. Here are a few things I've learned so far.

There should be 3 types of polynomial representation:

    1. Human read and writeable
    2. Rigid grammar (Single spaced between all numbers, operators and identifiers, no unary signs (+, -))
    3. Object representation

("Identifiers"? We need to call words something that can be both variables, constants, and units.)

There can be steps to convert from human-formatted to rigid
There is a parser to change rigid to object
There could be a process to convert object directly to human readable

You should be able to add, subtract, multiply and divide polynomial
Multiply will be most common, You could have one like so (rigid syntax):

Circumference: poly('r * cm * 3.1415')
CmToIn: poly('in / 2.54cm')
CircAndConvertCmToIn: Circumference * CmToIn
    > r * in * 1.24 `valid polynomial`

Calculate a polynomial by replacing variables with numbers
CircAndConvertCmToIn.calc({r: 1.0})
    > 1.24in `polynomial (because it includes an identifier) get the value with poly.calc({r: 1.0}).num`

Wait, that's weird. Should the input be specified as cm? I mean, it doesn't have to be, it's just recommended.

You could do the same like so:

CircAndConvertCmToIn * poly('1.0 / r')

Calculus
--------

SalesTrajectory: p(2x + 3)
SalesTrajectory.d()
    > 2 `This is a polynomial`
SalesTrajectory.d({x: 100})
    > 2 `This is a number - It is 2 for all x, so, you know`

SalesTrajectory.i()
    > x^2 + 3x + C `polynomial`
SalesTrajectory.i({x: [100, 110]})
    > 2130 `number`

*/
</script>
